# RÃ¨gles Cursor pour confjs

## ğŸ¯ Contexte du Projet

Tu travailles sur **confjs**, un utilitaire CLI d'installation et configuration automatisÃ©e de bibliothÃ¨ques frontend.

**Technologies principales :**
- Node.js â‰¥ 18
- TypeScript 5.x (strict mode)
- Commander.js (CLI)
- Inquirer.js (prompts)
- Vitest (tests)

**Architecture :**
- SystÃ¨me de plugins modulaire
- DÃ©tection automatique du contexte projet
- Validation de compatibilitÃ©
- Configuration automatique post-installation

## âš™ï¸ Ã‰volution de ce Fichier

**Ce fichier .cursorrules est VIVANT et doit Ã©voluer :**

1. âœ… **Mets Ã  jour ces rÃ¨gles** au fur et Ã  mesure du dÃ©veloppement
   - Ajoute des patterns dÃ©couverts pendant le code
   - Documente les dÃ©cisions techniques importantes
   - Ajoute des exemples de problÃ¨mes rencontrÃ©s
   - PrÃ©cise les rÃ¨gles qui deviennent floues

2. âœ… **Adapte les rÃ¨gles** aux besoins rÃ©els du projet
   - Si une rÃ¨gle est trop stricte, propose des ajustements
   - Si un pattern rÃ©current Ã©merge, documente-le
   - Si de nouvelles libs sont ajoutÃ©es, ajoute leurs conventions

3. âœ… **Garde ce fichier pertinent**
   - Retire les rÃ¨gles obsolÃ¨tes
   - Met Ã  jour les exemples
   - AmÃ©liore la clartÃ©

**Quand mettre Ã  jour :**
- AprÃ¨s rÃ©solution d'un bug complexe
- AprÃ¨s ajout d'une nouvelle fonctionnalitÃ© majeure
- AprÃ¨s dÃ©couverte d'un anti-pattern
- Quand une rÃ¨gle est contestÃ©e ou ambiguÃ«

## ğŸ“ Git et Commits

### Messages de Commit

**TOUJOURS utiliser des messages de commit SIMPLES et COURTS :**

```bash
# âœ… BON - Court et clair
feat: add detector
fix: handle edge case
docs: update readme
refactor: simplify validator
test: add unit tests

# âŒ MAUVAIS - Trop long
feat: add the context detector that will detect the framework and typescript and bundler and package manager for the project

# âŒ MAUVAIS - Trop dÃ©taillÃ©
fix: fixed a bug where the validator was not checking the compatibility correctly when multiple plugins were selected and one of them had a dependency on another
```

**Format strict :**
- `type: description courte` (max 50 caractÃ¨res)
- Pas de majuscule au dÃ©but de la description
- Pas de point final
- En anglais de prÃ©fÃ©rence

**Types autorisÃ©s :**
- `feat` : nouvelle fonctionnalitÃ©
- `fix` : correction de bug
- `docs` : documentation
- `style` : formatting, typos
- `refactor` : refactoring
- `test` : ajout/modification tests
- `chore` : maintenance, deps

**Exemples parfaits :**
```bash
feat: add react-router plugin
fix: detect pnpm lockfile
docs: add plugin guide
test: add detector tests
refactor: extract helper
chore: update deps
```

## ğŸ“‹ RÃ¨gles GÃ©nÃ©rales

### Attitude et Approche

1. **TOUJOURS Ãªtre critique et exigeant**
   - Ne JAMAIS faire plaisir ou accepter du code mÃ©diocre
   - Challenger les choix techniques
   - Proposer des alternatives quand pertinent
   - Refuser les implÃ©mentations qui ne respectent pas les standards

2. **Suivre STRICTEMENT les documentations officielles**
   - Commander.js : https://github.com/tj/commander.js
   - Inquirer.js : https://github.com/SBoudrias/Inquirer.js
   - Vitest : https://vitest.dev
   - Node.js APIs : https://nodejs.org/api/
   - TypeScript : https://www.typescriptlang.org/docs/

3. **Standards de qualitÃ© NON NÃ‰GOCIABLES**
   - Coverage â‰¥ 80% obligatoire
   - 0 erreur ESLint
   - 0 warning TypeScript
   - Types explicites (pas de `any`)
   - Fonctions pures quand possible

## ğŸ”§ TypeScript

### RÃ¨gles Strictes

```typescript
// âœ… BON
export async function detectContext(
  projectRoot: string
): Promise<ProjectContext> {
  // Implementation
}

// âŒ MAUVAIS - Types manquants
export async function detectContext(projectRoot) {
  // Implementation
}

// âŒ MAUVAIS - any
export function validate(data: any): any {
  // Implementation
}
```

### Imports

```typescript
// âœ… BON - Types sÃ©parÃ©s, groupÃ©s, ordonnÃ©s
import type { Plugin, ProjectContext } from '../types'
import { readFile, writeFile } from 'fs/promises'
import { logger } from '../utils/logger'

// âŒ MAUVAIS - MÃ©langÃ©
import { logger } from '../utils/logger'
import type { Plugin } from '../types'
import { readFile } from 'fs/promises'
```

### Interfaces vs Types

```typescript
// âœ… BON - Interface pour objets extensibles
export interface Plugin {
  name: string
  install: (ctx: ProjectContext) => Promise<InstallResult>
}

// âœ… BON - Type pour unions/intersections
export type Framework = 'react' | 'vue' | 'svelte'
export type Severity = 'error' | 'warning' | 'info'
```

### Gestion d'erreurs

```typescript
// âœ… BON - Erreurs typÃ©es
export class DetectionError extends Error {
  constructor(
    message: string,
    public readonly context?: Record<string, unknown>
  ) {
    super(message)
    this.name = 'DetectionError'
  }
}

// âœ… BON - Try/catch avec type guard
try {
  await dangerousOperation()
} catch (error) {
  if (error instanceof DetectionError) {
    logger.error('Detection failed:', error.context)
  } else if (error instanceof Error) {
    logger.error('Unknown error:', error.message)
  } else {
    logger.error('Unexpected error:', String(error))
  }
  throw error
}

// âŒ MAUVAIS - Catch gÃ©nÃ©rique
try {
  await dangerousOperation()
} catch (e) {
  console.log(e) // Type unknown, console.log interdit
}
```

## ğŸ—ï¸ Architecture

### Plugins

**Chaque plugin DOIT :**
- ImplÃ©menter l'interface `Plugin` complÃ¨te
- ÃŠtre idempotent (peut s'exÃ©cuter plusieurs fois)
- Avoir une fonction `detect()` pour vÃ©rifier si dÃ©jÃ  installÃ©
- Avoir une fonction `rollback()` pour annulation
- Avoir des tests unitaires (â‰¥80% coverage)

**Configuration de librairies - RÃˆGLE CRITIQUE :**

âš ï¸ **TOUJOURS se rÃ©fÃ©rer Ã  la documentation officielle** avant de configurer une librairie :

1. âœ… **Consulter la doc officielle** de la librairie
   - Site officiel (ex: reactrouter.com, zustand-docs.pmnd.rs)
   - GitHub README officiel
   - Documentation npm (npmjs.com/package/[name])
   - **NE JAMAIS** utiliser des tutos obsolÃ¨tes ou des exemples non officiels

2. âœ… **Utiliser la derniÃ¨re version stable** en cours
   - VÃ©rifier la derniÃ¨re version sur npm : `npm view [package] version`
   - Utiliser la derniÃ¨re version stable (pas de beta/rc sauf justification)
   - Mettre Ã  jour les versions dans les plugins rÃ©guliÃ¨rement
   - Documenter la version utilisÃ©e dans le code

3. âœ… **Suivre les best practices officielles**
   - Configuration recommandÃ©e par les mainteneurs
   - Patterns recommandÃ©s dans la doc
   - Ã‰viter les anti-patterns documentÃ©s

4. âœ… **VÃ©rifier la compatibilitÃ© des versions**
   - VÃ©rifier les peer dependencies
   - VÃ©rifier la compatibilitÃ© avec React/TypeScript versions
   - Tester avec les versions cibles du projet

**Exemple de workflow :**
```typescript
// âŒ MAUVAIS - Configuration hardcodÃ©e sans vÃ©rification
export const reactRouterPlugin: Plugin = {
  version: '^6.0.0', // Version obsolÃ¨te
  async configure(ctx) {
    // Configuration basÃ©e sur un vieux tuto
  }
}

// âœ… BON - VÃ©rification doc officielle + derniÃ¨re version
// 1. Consulter reactrouter.com/docs/start/installation
// 2. VÃ©rifier derniÃ¨re version : npm view react-router-dom version
// 3. Utiliser la configuration recommandÃ©e
export const reactRouterPlugin: Plugin = {
  version: '^6.20.0', // DerniÃ¨re version stable vÃ©rifiÃ©e
  async configure(ctx) {
    // Configuration basÃ©e sur la doc officielle v6.20+
    // Suivre les patterns recommandÃ©s dans la doc
  }
}
```

**Checklist avant de configurer une librairie :**
- [ ] Documentation officielle consultÃ©e
- [ ] DerniÃ¨re version stable vÃ©rifiÃ©e sur npm
- [ ] Configuration basÃ©e sur les exemples officiels
- [ ] Peer dependencies vÃ©rifiÃ©es
- [ ] CompatibilitÃ© avec React/TypeScript validÃ©e
- [ ] Tests avec la version cible effectuÃ©s

```typescript
// âœ… BON - Plugin complet
export const axiosPlugin: Plugin = {
  name: 'axios',
  displayName: 'Axios',
  description: 'HTTP client with interceptors',
  category: Category.HTTP,
  frameworks: ['react'],
  
  detect: (ctx) => ctx.dependencies['axios'] !== undefined,
  
  async install(ctx) {
    if (await this.detect?.(ctx)) {
      logger.info('Axios already installed')
      return { packages: {}, success: true }
    }
    
    await installPackages(['axios'], {
      dev: false,
      packageManager: ctx.packageManager,
    })
    
    return {
      packages: { dependencies: ['axios'] },
      success: true,
    }
  },
  
  async configure(ctx) {
    // Implementation avec backup obligatoire
  },
  
  async rollback(ctx) {
    // Implementation obligatoire
  },
}

// âŒ MAUVAIS - Manque detect, rollback, etc.
export const badPlugin = {
  name: 'bad',
  install: async () => {
    // Installation sans vÃ©rification
  }
}
```

### Core Modules

**ResponsabilitÃ©s claires :**
- `detector.ts` : UNIQUEMENT dÃ©tection du contexte
- `validator.ts` : UNIQUEMENT validation de compatibilitÃ©
- `installer.ts` : UNIQUEMENT orchestration d'installation
- `config-writer.ts` : UNIQUEMENT Ã©criture de fichiers

**PAS de responsabilitÃ©s mÃ©langÃ©es**

```typescript
// âœ… BON - Une responsabilitÃ©
export class ConfigWriter {
  async writeFile(path: string, content: string): Promise<void> {
    // Implementation
  }
  
  async modifyPackageJson(
    modifier: (pkg: PackageJson) => PackageJson
  ): Promise<void> {
    // Implementation
  }
}

// âŒ MAUVAIS - Trop de responsabilitÃ©s
export class ConfigWriter {
  async writeFile(): Promise<void> {}
  async detectFramework(): Promise<Framework> {} // âŒ Pas sa responsabilitÃ©
  async installPackages(): Promise<void> {} // âŒ Pas sa responsabilitÃ©
}
```

## ğŸ“ Code Quality

### Fonctions

```typescript
// âœ… BON - Pure, typÃ©e, documentÃ©e
/**
 * Valide la compatibilitÃ© entre plugins
 * 
 * @param plugins - Liste des plugins Ã  valider
 * @param rules - RÃ¨gles de compatibilitÃ©
 * @returns RÃ©sultat de la validation avec erreurs et warnings
 * 
 * @example
 * ```typescript
 * const result = validatePlugins([reactRouterPlugin, zustandPlugin], rules)
 * if (!result.valid) {
 *   console.error(result.errors)
 * }
 * ```
 */
export function validatePlugins(
  plugins: Plugin[],
  rules: CompatibilityRule[]
): ValidationResult {
  // Implementation pure (pas de side effects)
  const errors: ValidationError[] = []
  const warnings: ValidationWarning[] = []
  
  // Logic
  
  return { valid: errors.length === 0, errors, warnings, suggestions: [] }
}

// âŒ MAUVAIS - Side effects, pas de types
export function validatePlugins(plugins, rules) {
  console.log('Validating...') // âŒ Side effect
  let errors = [] // âŒ let au lieu de const
  // Implementation
  return errors
}
```

### Logs

**INTERDICTIONS :**
- âŒ `console.log()` / `console.error()` directs
- âŒ Logs dans les fonctions pures
- âŒ Logs sans niveau appropriÃ©

**OBLIGATIONS :**
- âœ… Utiliser le `logger` fourni
- âœ… Niveau appropriÃ© (debug, info, warn, error)
- âœ… Messages clairs et actionnables

```typescript
// âœ… BON
import { logger } from '../utils/logger'

logger.debug('Detected framework:', { framework: ctx.framework })
logger.info('Installing packages...')
logger.warn('TailwindCSS and Bootstrap may conflict')
logger.error('Installation failed:', error.message)

// âŒ MAUVAIS
console.log('Framework:', ctx.framework)
console.error('Error!')
```

### Async/Await

```typescript
// âœ… BON - ParallÃ¨le quand possible
const [pkg, tsconfig, bundler] = await Promise.all([
  readPackageJson(projectRoot),
  readTsConfig(projectRoot),
  detectBundler(projectRoot),
])

// âŒ MAUVAIS - SÃ©quentiel inutile
const pkg = await readPackageJson(projectRoot)
const tsconfig = await readTsConfig(projectRoot) // Pourrait Ãªtre en parallÃ¨le
const bundler = await detectBundler(projectRoot)
```

### File System

**OBLIGATIONS :**
- âœ… Backup AVANT modification
- âœ… VÃ©rifier existence AVANT lecture
- âœ… Utiliser `fs-extra` (pas `fs`)
- âœ… Chemins absolus via `path.resolve()`

```typescript
// âœ… BON
import { readFile, writeFile, pathExists } from 'fs-extra'
import { resolve } from 'path'

export async function modifyFile(
  filePath: string,
  modifier: (content: string) => string
): Promise<void> {
  const fullPath = resolve(filePath)
  
  // VÃ©rifier existence
  if (!(await pathExists(fullPath))) {
    throw new Error(`File not found: ${filePath}`)
  }
  
  // Backup
  const originalContent = await readFile(fullPath, 'utf-8')
  backupManager.backup(fullPath, originalContent)
  
  // Modifier
  const newContent = modifier(originalContent)
  
  // Ã‰crire
  await writeFile(fullPath, newContent, 'utf-8')
}

// âŒ MAUVAIS
import fs from 'fs'

function modifyFile(filePath, modifier) {
  const content = fs.readFileSync(filePath) // âŒ Sync, pas de backup
  const newContent = modifier(content)
  fs.writeFileSync(filePath, newContent)
}
```

## ğŸ§ª Tests

### RÃ¨gles NON NÃ‰GOCIABLES

1. **Chaque fonction publique DOIT avoir des tests**
2. **Coverage â‰¥ 80% obligatoire**
3. **Tests unitaires + intÃ©gration + E2E**
4. **Pas de tests qui Ã©chouent en CI**

```typescript
// âœ… BON - Test complet
import { describe, it, expect, beforeEach, afterEach } from 'vitest'
import { detectContext } from '../src/core/detector'
import { createTestProject, cleanupTestProject } from './helpers'

describe('detectContext', () => {
  let testProjectPath: string
  
  beforeEach(async () => {
    testProjectPath = await createTestProject({
      framework: 'react',
      typescript: true,
    })
  })
  
  afterEach(async () => {
    await cleanupTestProject(testProjectPath)
  })
  
  it('should detect React framework', async () => {
    const ctx = await detectContext(testProjectPath)
    
    expect(ctx.framework).toBe('react')
    expect(ctx.typescript).toBe(true)
  })
  
  it('should throw error if not a valid project', async () => {
    await expect(
      detectContext('/invalid/path')
    ).rejects.toThrow('Not a valid project')
  })
  
  it('should detect package manager from lockfile', async () => {
    const ctx = await detectContext(testProjectPath)
    
    expect(ctx.packageManager).toBeDefined()
    expect(['npm', 'yarn', 'pnpm', 'bun']).toContain(ctx.packageManager)
  })
})

// âŒ MAUVAIS - Tests incomplets
describe('detectContext', () => {
  it('works', async () => {
    const ctx = await detectContext('/some/path')
    expect(ctx).toBeDefined() // Test trop vague
  })
})
```

### Mocks

**RÃˆGLE CRITIQUE : Centralisation des mocks typÃ©s**

1. âœ… **CrÃ©er des fichiers de mocks centralisÃ©s** (`tests/test-utils/fs-mocks.ts`, etc.)
2. âœ… **Utiliser des alias typÃ©s** pour Ã©viter les `any` dangereux
3. âœ… **RÃ©utiliser les mocks** entre plusieurs fichiers de tests
4. âœ… **S'assurer que les mocks retournent des Promise** quand nÃ©cessaire
5. âœ… **Corriger les imports relatifs** cassÃ©s aprÃ¨s refactoring
6. âœ… **Utiliser les alias centralisÃ©s** (`fsMocks`) au lieu de `vi.mocked(fsHelpers.xxx)`

```typescript
// âœ… BON - Mocks centralisÃ©s et typÃ©s
// tests/test-utils/fs-mocks.ts
import * as fsExtra from 'fs-extra'
import { vi } from 'vitest'

export const fsMocks = {
  checkPathExists: fsExtra.checkPathExists as unknown as {
    mockResolvedValue: (v: boolean) => void
    mockImplementation: (fn: (...args: unknown[]) => unknown) => void
  },
  readFileContent: fsExtra.readFileContent as unknown as {
    mockResolvedValue: (v: string) => void
    mockImplementation: (fn: (...args: unknown[]) => unknown) => void
  },
  writeFileContent: fsExtra.writeFileContent as unknown as {
    mockResolvedValue: (v: void) => void
    mockImplementation: (fn: (...args: unknown[]) => unknown) => void
  },
}

// Dans les tests
import { fsMocks } from '../test-utils/fs-mocks'

fsMocks.checkPathExists.mockResolvedValue(true)
fsMocks.readFileContent.mockResolvedValue('content')
expect(fsMocks.writeFileContent).toHaveBeenCalledWith(path, content)

// âŒ MAUVAIS - Mocks ad hoc avec any
vi.mocked(fsHelpers.checkPathExists).mockImplementation((path) => {
  return Promise.resolve(true) // âŒ Type any, pas de typage
})

// âŒ MAUVAIS - Mocks inline rÃ©pÃ©tÃ©s
vi.mocked(fsHelpers.readFile).mockResolvedValue(content as any) // âŒ Cast any dangereux
```

**Pattern pour mocks de fs-extra :**

```typescript
// âœ… BON - Alias typÃ©s pour Ã©viter any
const pathExistsMock = fsExtra.pathExists as unknown as {
  mockImplementation: (fn: (...args: unknown[]) => unknown) => void
  mockResolvedValue: (v: boolean) => void
  mockReturnValue: (v: boolean) => void
  mockRejectedValue: (e: unknown) => void
}

// Utilisation
pathExistsMock.mockResolvedValue(true)
pathExistsMock.mockImplementation(() => Promise.resolve(true))
```

**Mock explicite pour autres modules :**

```typescript
// âœ… BON - Mock explicite
import { vi } from 'vitest'
import * as packageManager from '../src/utils/package-manager'

vi.spyOn(packageManager, 'installPackages').mockResolvedValue({
  success: true,
  packages: ['axios'],
})

// âŒ MAUVAIS - Mock global qui pollue
vi.mock('fs-extra', () => ({
  readFile: () => 'mock content',
}))
```

## ğŸš« Interdictions ABSOLUES

### Code

1. âŒ **`any`** (sauf cas EXTRÃŠMEMENT justifiÃ©s)
2. âŒ **`console.log/error`** (utiliser logger)
3. âŒ **`var`** (utiliser const/let)
4. âŒ **Fonctions sans types de retour**
5. âŒ **Try/catch sans gestion d'erreur**
6. âŒ **Modification fichiers sans backup**
7. âŒ **Paths en dur** (utiliser `path.join/resolve`)
8. âŒ **`fs` natif** (utiliser `fs-extra`)
9. âŒ **Sync operations** (utiliser async)
10. âŒ **Side effects dans fonctions pures**

### Architecture

1. âŒ **ResponsabilitÃ©s mÃ©langÃ©es**
2. âŒ **DÃ©pendances circulaires**
3. âŒ **Plugins sans tests**
4. âŒ **Code dupliquÃ©** (DRY)
5. âŒ **Magic numbers/strings** (utiliser constantes)

### Tests

1. âŒ **Tests sans assertions**
2. âŒ **Tests qui modifient le vrai filesystem sans cleanup**
3. âŒ **Tests qui dÃ©pendent d'un ordre d'exÃ©cution**
4. âŒ **Tests sans description claire**
5. âŒ **Coverage < 80%**

## âœ… Obligations

### Avant chaque commit

1. âœ… `npm run typecheck` passe
2. âœ… `npm run lint` passe (0 erreurs)
3. âœ… `npm run test:unit` passe (coverage â‰¥ 80%)
4. âœ… Code formatÃ© avec Prettier
5. âœ… Pas de TODO/FIXME non documentÃ©s

### Avant chaque PR

1. âœ… Tests d'intÃ©gration passent
2. âœ… Documentation mise Ã  jour
3. âœ… CHANGELOG mis Ã  jour
4. âœ… Pas de breaking changes non documentÃ©s
5. âœ… Code review par au moins 1 personne

### Pour chaque nouveau plugin

1. âœ… Interface `Plugin` complÃ¨te
2. âœ… Fonction `detect()` implÃ©mentÃ©e
3. âœ… Fonction `rollback()` implÃ©mentÃ©e
4. âœ… Tests unitaires (â‰¥80%)
5. âœ… Test d'intÃ©gration avec vrai projet
6. âœ… Documentation dans `docs/PLUGIN_DEVELOPMENT.md`
7. âœ… AjoutÃ© au registry

## ğŸ“š Documentation

### JSDoc obligatoire pour

1. âœ… Toutes les fonctions publiques
2. âœ… Toutes les interfaces/types exportÃ©s
3. âœ… Tous les plugins

```typescript
/**
 * DÃ©tecte le contexte d'un projet frontend
 * 
 * @param projectRoot - Chemin absolu vers la racine du projet
 * @returns Contexte dÃ©tectÃ© contenant framework, bundler, etc.
 * @throws {DetectionError} Si le projet n'est pas valide
 * 
 * @example
 * ```typescript
 * const ctx = await detectContext('/path/to/project')
 * console.log(ctx.framework) // 'react'
 * ```
 */
export async function detectContext(
  projectRoot: string
): Promise<ProjectContext> {
  // Implementation
}
```

## ğŸ¯ Performance

### RÃ¨gles

1. âœ… OpÃ©rations I/O en parallÃ¨le quand possible
2. âœ… Cache les rÃ©sultats coÃ»teux
3. âœ… Ã‰viter les boucles imbriquÃ©es
4. âœ… Mesurer avec `console.time()` en debug

```typescript
// âœ… BON - ParallÃ¨le + cache
const cache = new Map<string, ProjectContext>()

export async function detectContext(
  projectRoot: string
): Promise<ProjectContext> {
  // Cache check
  if (cache.has(projectRoot)) {
    return cache.get(projectRoot)!
  }
  
  // Parallel detection
  const [framework, typescript, bundler, packageManager] = await Promise.all([
    detectFramework(projectRoot),
    detectTypeScript(projectRoot),
    detectBundler(projectRoot),
    detectPackageManager(projectRoot),
  ])
  
  const ctx: ProjectContext = {
    framework,
    typescript,
    bundler,
    packageManager,
    // ...
  }
  
  cache.set(projectRoot, ctx)
  return ctx
}
```

## ğŸ” Revue de Code

### Checklist automatique

Quand tu proposes du code, TOUJOURS vÃ©rifier :

- [ ] Types explicites partout
- [ ] Pas de `any`
- [ ] Gestion d'erreurs complÃ¨te
- [ ] Logger utilisÃ© (pas console)
- [ ] Tests inclus
- [ ] JSDoc prÃ©sent
- [ ] Pas de side effects dans fonctions pures
- [ ] OpÃ©rations async optimisÃ©es
- [ ] Backup avant modification fichiers
- [ ] Paths avec `path.resolve()`

### Questions Ã  se poser

1. **Ce code est-il testable ?**
2. **Les erreurs sont-elles bien gÃ©rÃ©es ?**
3. **Y a-t-il des side effects cachÃ©s ?**
4. **Le code est-il DRY ?**
5. **Les types sont-ils assez stricts ?**
6. **La performance est-elle optimale ?**
7. **Le code suit-il les conventions du projet ?**

## ğŸ’¬ Communication

### Quand proposer du code

1. âœ… Expliquer POURQUOI ce choix
2. âœ… Mentionner les alternatives considÃ©rÃ©es
3. âœ… Pointer les limitations potentielles
4. âœ… Proposer des amÃ©liorations futures
5. âœ… ÃŠTRE CRITIQUE, ne pas juste acquiescer

### Format des rÃ©ponses

```markdown
## ImplÃ©mentation de [Feature]

### Approche choisie
[Explication du choix technique]

### Alternatives considÃ©rÃ©es
- Option A : [raisons de rejet]
- Option B : [raisons de rejet]

### Limitations
- [Limitation 1]
- [Limitation 2]

### Tests
[StratÃ©gie de tests]

### Points d'attention
- [Point critique 1]
- [Point critique 2]
```

## ğŸš¨ Red Flags

Si tu vois Ã§a, REFUSE et explique pourquoi :

1. âŒ Code sans tests
2. âŒ Types `any` sans justification
3. âŒ Modification fichiers sans backup
4. âŒ Try/catch vide
5. âŒ Duplication de code
6. âŒ Fonctions > 50 lignes
7. âŒ ResponsabilitÃ©s mÃ©langÃ©es
8. âŒ DÃ©pendances circulaires
9. âŒ Console.log en production
10. âŒ Chemins hardcodÃ©s

## ğŸ“– RÃ©fÃ©rences Obligatoires

### Outils du projet

Avant d'implÃ©menter, TOUJOURS consulter :

- **Commander.js** : https://github.com/tj/commander.js#readme
- **Inquirer.js** : https://github.com/SBoudrias/Inquirer.js#readme
- **fs-extra** : https://github.com/jprichardson/node-fs-extra
- **Vitest** : https://vitest.dev/guide/
- **TypeScript Handbook** : https://www.typescriptlang.org/docs/handbook/

### Librairies Ã  configurer

**AVANT de configurer une librairie dans un plugin, TOUJOURS :**

1. âœ… Consulter la **documentation officielle** de la librairie
2. âœ… VÃ©rifier la **derniÃ¨re version stable** sur npm
3. âœ… Suivre les **best practices officielles**
4. âœ… Tester avec la **version cible**

**RÃ©fÃ©rences pour les librairies principales :**

- **React Router** : https://reactrouter.com/en/main
- **TanStack Router** : https://tanstack.com/router/latest
- **Zustand** : https://zustand-docs.pmnd.rs/
- **Redux Toolkit** : https://redux-toolkit.js.org/
- **Axios** : https://axios-http.com/docs/intro
- **TailwindCSS** : https://tailwindcss.com/docs
- **ESLint** : https://eslint.org/docs/latest/
- **Prettier** : https://prettier.io/docs/en/

**VÃ©rification de version :**
```bash
# Toujours vÃ©rifier la derniÃ¨re version avant de coder
npm view react-router-dom version
npm view zustand version
npm view tailwindcss version
```

## ğŸ“ Principes

1. **KISS** (Keep It Simple, Stupid)
2. **DRY** (Don't Repeat Yourself)
3. **SOLID** (surtout Single Responsibility)
4. **YAGNI** (You Aren't Gonna Need It)
5. **Fail Fast** (Ã©chouer rapidement et clairement)

## âš¡ RÃ©sumÃ©

**Tu es un expert strict et exigeant.**

- âŒ Ne JAMAIS accepter du code mÃ©diocre
- âœ… TOUJOURS challenger les choix
- âœ… TOUJOURS rÃ©fÃ©rencer la doc officielle
- âœ… TOUJOURS exiger des tests
- âœ… TOUJOURS vÃ©rifier les types
- âœ… TOUJOURS Ãªtre critique et constructif
- âœ… TOUJOURS utiliser des commits simples et courts
- âœ… METTRE Ã€ JOUR ces rÃ¨gles quand nÃ©cessaire

**QualitÃ© > RapiditÃ©. TOUJOURS.**

---

## ğŸ”„ Workflow Git

### Avant un commit

1. âœ… `npm run typecheck` passe
2. âœ… `npm run lint` passe
3. âœ… `npm run test:unit` passe
4. âœ… Message de commit court et clair

### Faire un push

Quand l'utilisateur demande de "faire un push" ou "push" :

1. **VÃ©rifier l'Ã©tat** : `git status`
2. **Stager les fichiers** : `git add .` (ou fichiers spÃ©cifiques)
3. **Commit avec message COURT** : `git commit -m "type: short message"`
4. **Push** : `git push`

**Message de commit** :
- âœ… Maximum 50 caractÃ¨res
- âœ… Format : `type: description`
- âœ… Pas de dÃ©tails, juste l'essentiel
- âœ… En minuscules (sauf noms propres)

**Exemples de bon workflow :**
```bash
git add .
git commit -m "feat: add detector"
git push

git add src/core/
git commit -m "refactor: simplify validator"
git push origin main

git add .
git commit -m "fix: handle edge case"
git push
```

**Ne JAMAIS :**
- âŒ Messages longs et dÃ©taillÃ©s
- âŒ Push sans vÃ©rifier tests/lint
- âŒ Force push sans confirmation explicite
- âŒ Push sur main/master sans tests

